---
title: 关于JavaScript的作用域及闭包
date: 2016-8-8 20:44:37
tags:
  - JavaScript
  - 闭包
  - 作用域
categories:
  - 前端
  - JavaScript
---
## 前言
&emsp;&emsp;作用域的概念十分重要，对于深入了解JavaScript内部的运行原理有很重要的意义。闭包是个神奇而且十分有用的东西，而却不容易理解。所以，打算把我对其的理解写出来，加深自己的印象。

## 作用域
&emsp;&emsp;作用域实际上是根据名称查找变量的一套规则，这套规则用来管理引擎如何在当前作用域以及嵌套的子作用域中根据标识符名称进行变量查找。
&emsp;&emsp;可能有点拗口，举个例子：
```JavaScript
function foo(a){
  var b = a * 2;
  function bar(c){
    console.log(a,b,c);
  }
  bar(b * 3);
}
foo(2);   //2 4 12
```
<!-- more -->
&emsp;&emsp;在这个例子中有三个逐层嵌套的作用域：
1. 包含着整个全局作用域，只有一个标识符：`foo`;
2. 包含着函数foo所创建的作用域，其中有三个标识符：`a`,`bar`,`b`;
3. 包含着`bar`所创建的作用域，其中只有一个标识符:`c`;

&emsp;&emsp;当引擎执行到`console.log(a,b,c)`时，需要查找a,b,c三个变量的引用。首先会从最内部的作用域开始，也就是从`bar`的作用域开始查找。该作用域下没有变量a,因此会继续查询上一个作用域，即`foo`的作用域，在这里找到了a，同理变量b也在这层被找到。变量c在最内层就被找到，因此不会再继续向上查找。

&emsp;&emsp;作用域查找始终从**运行时所处的最内部作用域**开始，逐级向外进行，直到遇见第一个匹配的标识符为止。这叫做“遮蔽效应”，内部的标识符遮蔽了外部的标识符。`foo()`函数是在全局作用域中运行，因此会从全局作用域开始查找，而不是从bar的作用域开始查找。

### 函数作用域
&emsp;&emsp;值得注意的是，JavaScript没有**块级作用域**，而是使用了**函数作用域**。这点在上面的例子中就有体现，每个函数内实际上就是一个作用域。属于这个函数的全部变量都可以在整个函数的范围内使用及复用，然而在该函数的作用域外是不能访问其函数内部的变量和定义的函数。
```JavaScript
function foo(){
  var a = 3;
  console.log(a);
}

foo();          //3
console.log(a)  //ReferenceError: a is not defined
```
&emsp;&emsp;在上例中，调用`foo()`函数后正确打印出变量a的值，因为在函数`foo`的作用域内找到了该变量。而在全局作用域中要打印出变量a的值则会报错，变量a未定义，因为外部的作用域是不能访问内部作用域的属性。

### 作用域链
&emsp;&emsp;当某个函数第一次被调用时，会创建一个执行环境(execution context)及相应的作用域链，并把作用域链复制给一个特殊的内部属性([[Scope]])。这个作用域链是一个对象列表或者链表，这组对象定义了这段代码“作用域中”的变量。当需要查找某变量，它会从链中第一个对象开始查找，如果未找到则查找链上的下一个对象。

&emsp;&emsp;在全局作用域中，作用域链由一个全局对象组成。在不包含嵌套的函数体内，作用域链上有两个对象，第一个是定义函数参数和局部变量的对象，第二个是全局对象。

![作用域链](http://7xk5u3.com1.z0.glb.clouddn.com/closure1.jpg)
&emsp;&emsp;上图就是不包含嵌套的函数体内的作用域链，第一位就是函数的活动对象(activation object)，第二位是全局对象。

## 闭包
&emsp;&emsp;函数对象可以通过作用域链相互关联起来，函数体内部的变量都可以保存在函数作用域内，这种特性就称为“闭包”。我们来看个例子：
```JavaScript
function foo(){
  var a = 2;
  function bar(){
    console.log(a);
  }
  return bar;
}
var baz = foo();
baz();  //2
```
&emsp;&emsp;函数`bar()`的词法作用域能够访问`foo()`的内部作用域。然后将`bar()`函数本身作为值类型传递，当函数`foo()`执行后，其返回值(内部的bar()函数)赋值给变量`baz`并调用`baz()`。实际上只是通过不同标识符调用了内部的函数`bar()`，但它是在自己定义的作用域外地方被执行了。

&emsp;&emsp;当执行`baz()`函数时,就会根据作用域链的查找规则，从bar()内部开始查找变量a。如果你了解JavaScript的垃圾回收机制，那么你可能会有疑问。在函数`foo()`执行结束后，`foo()`的整个内部作用域都会被销毁，当然包括变量a。但我们却依旧可以在之后通过调用函数`baz()`访问到变量a，这是为什么呢？这正是因为闭包的作用，由于函数`bar()`是在函数`foo()`内部声明的，它拥有涵盖`foo()`内部作用域的闭包，使得该作用域一直存活不被清除，以供`bar()`随时引用。

&emsp;&emsp;`bar()`这个函数在定义时的作用域以外的地方被调用，正是闭包使得函数可以继续访问定义时的作用域。如果你理解了作用域链，那么闭包可以这样解释：函数定义时的作用域链到函数执行时依然有效。
