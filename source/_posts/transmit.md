---
title: 参数传递的规则
date: 2016-8-10 14:56:51
tags:
  - JavaScript
  - 作用域
  - 参数传递
categories:
  - 前端
  - JavaScript
---
## 前言
&emsp;&emsp;在SegmentFault上看到一个关于JavaScript的问题，是这样的：
```JavaScript
function box(obj){
    obj.name='Lee';
    var obj = new Object();
    obj.name='kkk';
}

var obj = new Object();
box(obj);
alert(obj.name);  //'Lee'
```
&emsp;&emsp;为什么最终的结果是'Lee'而不是'kkk'呢？
<!-- more -->
## 相关概念
### 基本类型和引用类型
&emsp;&emsp;ECMAScript变量可能包含两种不同数据类型的值：基本类型值和引用类型值。基本类型值指的是那些保存在**栈内存**中的简单数据段，即这种值完全保存在内存中的一个位置。而引用类型值则是指那些保存在**堆内存**中的对象(对象类型)，意思是变量中保存的实际上只是一个指针，这个指针指向内存中的另一个位置，该位置保存对象。

&emsp;&emsp;5种基本数据类型：Undefined、Null、Boolean、Number和String，这5种基本数据类型的值保存在栈内存中，它们是**按值访问**的。而对象Object这种值大小不定，不能保存在栈内存中。但其内存地址大小固定，因此可以把内存地址保存在栈内存中。当查询引用类型变量时，首先读出内存地址再找到保存在堆中的值，这种查询方式叫做**按引用访问**。

### 变量复制
&emsp;&emsp;如果从一个变量向另一个变量复制基本类型的值，会在栈中创建一个新值，然后把该值复制到为新变量分配的位置上。而当一个变量向另一个变量复制引用类型的值时，同样也会将存储在栈中的值复制一份放在新变量的空间中。不同的是，这个值实际上是一个指针，指向存储在堆中的一个对象。复制结束后两个变量实际引用的是同一个对象。

```JavaScript
var obj1 = new Object();
var obj2 = obj1;
obj1.name = "CZH";
console.log(obj2.name); //"CZH"
```

### 传递参数
&emsp;&emsp;ECMAScript中所有函数的参数都是按值传递的。也就是说，把函数外部的值复制给函数内部的参数，就和把值从一个变量复制到另一个变量一样。在向参数传递基本类型的值时，被传递的值会被复制给一个局部变量(arguments对象中的一个元素)。在向参数传递引用类型的值时，会把这个值的内存中地址复制给一个局部变量，因此这个局部变量的变化会反映在函数的内部。

## 问题分析
&emsp;&emsp;了解了相关概念和规则后，我们再来看看这个问题，或许一切都迎刃而解。我对程序做了小改动，将外部的obj变量改为person变量，不影响程序效果，但能更好的理解。
```JavaScript
function box(obj){
    obj.name='Lee';
    var obj = new Object();
    obj.name='kkk';
}

var person = new Object();
box(person);
alert(person.name);  //'Lee'
```
&emsp;&emsp;首先，创建了一个对象，并将其保存在了变量person中。然后这个对象被传递到`box()`函数中，之后就被复制给了obj变量。此时person和obj引用的是同一个对象。于是，当在函数内部位obj添加name属性后，函数外部的person也将有所反映。

&emsp;&emsp;有人可能会问，这还是按值传递么？明明就是按引用传递啊。可这的的确确就是按值传递，只不过传递的值并不是对象本身，而是对象在内存中的地址。

&emsp;&emsp;继续程序的流程，在obj的name被修改为'Lee'后，又创建了一个新对象并赋值给变量obj，同时将其name属性设置为'kkk'。在新对象赋给obj之后，obj就已经保存的不是之前对象的地址了，而是新对象的地址。因此，再改变obj的name属性也是设置新对象的属性，原对象不受影响。而且在程序运行结束后，包括这个新创建的对象和变量obj都会被销毁。

&emsp;&emsp;如果你理解了引用类型数据的保存方式，可能会更好的理解这一过程。起初栈内存中有一个单元person保存着堆内存中一个对象的地址。在person被传递到函数中后，栈内存新生成一个单元obj，并将person单元中的值复制到这个新单元中。即person和obj这两个单元都保存着同样的地址值，这个地址值都是函数外生成的对象所对应的堆内存地址。不管通过哪个单元访问到对象并进行修改，当从另一个单元访问对象都会看到变化，因为两个单元对应着同一个对象。之后又创建了一个新对象，这个新对象在堆内存中的地址值，被保存在栈内存中的obj单元。此时栈内存中的person单元和obj单元中的值不再相同，也就是说指向了两个不同的对象。当修改obj所对应的对象时，自然不会影响到person所对应的对象。

&emsp;&emsp;这个题还涉及了变量提升的问题，但对整体思路没有影响，感兴趣可以了解一下。
